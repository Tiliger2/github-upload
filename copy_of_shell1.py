# -*- coding: utf-8 -*-
"""Copy of Shell1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EHR7AU4Pa3hNJuRJhWlr_JViPdM_okRx
"""

# -*- coding: utf-8 -*-
 
# Module List
import numpy  as np
import pandas as pd    
from   numba  import njit                      # For some speed gains                    
from   math   import radians as DegToRad       # Degrees to radians Conversion
 
from shapely.geometry import Point             # Used in constraint checking
from shapely.geometry.polygon import Polygon
 
from tqdm import tqdm                          # For Progressbar
# Use from tqdm import tqdm_notebook as tqdm for running in Jupyter Notebook  
# Use from tqdm import tqdm for running in IDE Environ 
 
 
 
def rotatedFrame(turb_coords, wind_drct):
 
    
    # so that the wind flow direction aligns with the +ve x-axis.
    wind_drct = wind_drct-90
    
    # Convert inflow wind direction from degrees to radians
    wind_drct = DegToRad(wind_drct)
 
    # Contants for coordinate transformation 
    cos_dir = np.cos(wind_drct)
    sin_dir = np.sin(wind_drct)
    
    # Coordinate Transformation. Rotate coordinates to downwind, crosswind coordinates 
    rotate_coords      =    np.zeros((turb_coords.shape[0],2), dtype=np.float32)
    rotate_coords[:,0] =    (turb_coords[:,0] * cos_dir) - (turb_coords[:,1] * sin_dir)
    rotate_coords[:,1] =    (turb_coords[:,0] * sin_dir) + (turb_coords[:,1] * cos_dir)
    
    return(rotate_coords)
 
 
@njit            # jensenParkWake is numba compiled function. Gives speed gains. 
def jensenParkWake(n_turbs, turb_diam, rotate_coords, power_curve, wind_sped):
 
    # turbine radius
    turb_rad = turb_diam/2
 
    # we use power_curve data as look up to estimate the thrust coeff.
    # of the turbine for the corresponding closest matching wind speed
    idx_foo  = np.argmin(np.abs(power_curve[:,0] - wind_sped))
    C_t      = power_curve[idx_foo,1]
    
    # Wake decay constant kw for the offshore case
    kw = 0.05 
    
    # velocity deficit suffered by each turbine for this particular wind instance
    # impact_on_ibyj - placeholder to calc vel deficit from all turbs on i                 
    impact_on_ibyj = np.zeros((n_turbs,n_turbs), dtype=np.float32) 
        
    # i - target turbine
    for i in range(n_turbs):   
        
        # looping over all other turbs to check their effect
        for j in range(n_turbs):             
            
            # Calculate the x-dist and the y-offset 
            # (wrt downwind/crosswind coordinates)
            x = rotate_coords[i,0] - rotate_coords[j,0]   
            y = rotate_coords[i,1] - rotate_coords[j,1]   
            
            # Naturally, no wake effect of turbine on itself
            if i!=j: 
                
                # either j not an upstream turbine or wake not happening 
                # on i because its outside of the wake region of j                    
                if x<=0 or np.abs(y) > (turb_rad + kw*x):  
                    impact_on_ibyj[i,j] = 0.0
                
                # otherwise, at target i, wake is happening due to j
                else:                               
                    impact_on_ibyj[i,j] = (1-np.sqrt(1-C_t))*((turb_rad/(turb_rad + kw*x))**2)
            
    # Calculate Total vel deficit from all upstream turbs, using sqrt of sum of sqrs
    sped_deficit = np.sqrt(np.sum(impact_on_ibyj**2, axis = 1))
 
    return(sped_deficit)
 
 
def partAEP(n_turbs, turb_diam, turb_coords, power_curve, wind_drct, wind_sped):
 
    # For given wind_drct rotate coordinates to downwind/crosswind 
    rotate_coords = rotatedFrame(turb_coords, wind_drct)
    
    # Use the jensen park wake model to calc speed deficits by wake
    sped_deficit = jensenParkWake(n_turbs, turb_diam, rotate_coords, power_curve, wind_sped)
    
    # Placeholder for storing power output of turbines
    turb_pwr = np.zeros(n_turbs, dtype=np.float32)
 
    # calculate the individual turbine power for effective wind speed
    for i in range(n_turbs):
        
        # Effective windspeed due to the happening wake
        wind_sped_eff = wind_sped*(1.0 - sped_deficit[i])
        
        # we use power_curve data as look up to estimate the power produced
        # by the turbine for the corresponding closest matching wind speed
        idx_foo = np.argmin(np.abs(power_curve[:,0] - wind_sped_eff))
        pwr     = power_curve[idx_foo,2]
        
        turb_pwr[i] = pwr
           
    # Sum the power from all turbines for this wind instance
    power = np.sum(turb_pwr)
    
    return power
 
 
def totalAEP(turb_diam, turb_coords, power_curve, wind_inst_freq):
 
    # number of turbines
    n_turbs        =   turb_coords.shape[0]
    assert n_turbs ==  50, "Error! Number of turbines is not 50."
    
    # direction 'slices' in degrees
    slices_drct   = np.roll(np.arange(10, 361, 10, dtype=np.float32), 1)
    ## slices_drct   = [360, 10.0, 20.0.......340, 350]
    n_slices_drct = slices_drct.shape[0]
    
    # speed 'slices'
    slices_sped   = [0.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 
                        18.0, 20.0, 22.0, 24.0, 26.0, 28.0, 30.0]
    n_slices_sped = len(slices_sped)-1
 
    # Power produced by the wind farm from each wind instance
    farm_pwr = np.zeros((wind_inst_freq.shape), dtype=np.float32)
    
    # Looping over every wind instance and calc Power
    # set disable=True for disabling progressbar
    for i in tqdm(range(n_slices_drct), disable=True):
        for j in range(n_slices_sped): 
            
            # take the mid value as effective speed
            wind_drct =  slices_drct[i]
            wind_sped = (slices_sped[j] + slices_sped[j+1])/2
            
            pwr  = partAEP(n_turbs, turb_diam, turb_coords, 
                           power_curve, wind_drct, wind_sped)
            
            farm_pwr[i,j] = pwr
    
    # multiply the respective values with the wind instance probabilities 
    farm_pwr = wind_inst_freq * farm_pwr
    
    # now sum all values
    farm_pwr = np.sum(farm_pwr)
    
    # multiply farm_pwr by hours in a year
    year_hours = 365.*24.
    AEP = year_hours*farm_pwr
    
    # Convert MWh to GWh
    AEP = AEP/1e3
    return(AEP)
 
 
def Aepcalc(pos, pc, wind):
 
    AEP = totalAEP(100, pos, pc, wind) 
 
    return AEP

def checkConstraints(turb_coords, turb_diam):

    bound_clrnc      = 50
    prox_constr_viol = False
    peri_constr_viol = False
    
    # create a shapely polygon object of the wind farm
    farm_peri = [(0, 0), (0, 4000), (4000, 4000), (4000, 0)]
    farm_poly = Polygon(farm_peri)
    
    # checks if for every turbine perimeter constraint is satisfied. 
    # breaks out if False anywhere
    for turb in turb_coords:
        turb = Point(turb)
        inside_farm   = farm_poly.contains(turb)
        correct_clrnc = farm_poly.boundary.distance(turb) >= bound_clrnc
        if (inside_farm == False or correct_clrnc == False):
            peri_constr_viol = True
            break
    
    # checks if for every turbines proximity constraint is satisfied. 
    # breaks out if False anywhere
    for i,turb1 in enumerate(turb_coords):
        for turb2 in np.delete(turb_coords, i, axis=0):
            if  np.linalg.norm(turb1 - turb2) < 4*turb_diam:
                prox_constr_viol = True
                break
    
    # print messages
    if  peri_constr_viol  == True  or prox_constr_viol == True:
          # print('Somewhere both perimeter constraint and proximity constraint are violated\n')
          return 0
    else: return 1
      #  print('Both perimeter and proximity constraints are satisfied !!\n')

gp = [0 for i in range(3901*3901)]
  
def gp_gen(pos):
  c=0
  for k in pos:
    c+=1
    print(c)
    for i in range(-400, 400):
      for j in range(-400, 400):
        if k[0]+i >= 50 and k[0]+i <= 3950 and k[1]+j >= 50 and k[1]+j <= 3950:
          if np.linalg.norm(k-[k[0]+i,k[1]+j])<=400:
            gp[(k[0] + i-50)*3900+ k[1] + j-50] += 1


def gp_rem(k):
  for i in range(-400, 400):
      for j in range(-400, 400):
        if k[0]+i >= 50 and k[0]+i <= 3950 and k[1]+j > 50 and k[1]+j < 3950:
          if np.linalg.norm(k-[k[0]+i,k[1]+j])<=400:
            gp[(k[0] + i-50)*3900+ k[1] + j-50] -= 1

def gp_add(k):
  for i in range(-400, 400):
      for j in range(-400, 400):
        if k[0]+i >= 50 and k[0]+i <= 3950 and k[1]+j > 50 and k[1]+j < 3950:
          if np.linalg.norm(k-[k[0]+i,k[1]+j])<=400:
            gp[(k[0] + i-50)*3900+ k[1] + j-50] += 1

  

def checkConstraints_pt(turb_coords, i, turb_diam):

        
    bound_clrnc      = 50
    prox_constr_viol = False
    

    # checks if for every turbines proximity constraint is satisfied. 
    # breaks out if False anywhere
    turb1 = turb_coords[i]
    for turb2 in np.delete(turb_coords, i, axis=0):
      if min(abs(turb1-turb2))<400:
        if  np.linalg.norm(turb1 - turb2) < 4*turb_diam:
            prox_constr_viol = True
            break
    
    # print messages
    if prox_constr_viol == True:
          # print('Somewhere both perimeter constraint and proximity constraint are violated\n')
          return 0
    else: return 1
      #  print('Both perimeter and proximity constraints are satisfied !!\n')

def getTurbLoc(turb_loc_file_name):
    
    df = pd.read_csv(turb_loc_file_name, sep=',')
    turb_coords = df.to_numpy(dtype = np.int)
    return(turb_coords)


def loadPowerCurve(power_curve_file_name):

    powerCurve = pd.read_csv(power_curve_file_name, sep=',')
    powerCurve = powerCurve.to_numpy(dtype = np.float32)
    return(powerCurve)
    

def binWindResourceData(wind_data_file_name):
    
    # Load wind data. Then, extracts the 'drct', 'sped' columns
    df = pd.read_csv(wind_data_file_name)
    wind_resource = df[['drct', 'sped']].to_numpy(dtype = np.float32)
    
    # direction 'slices' in degrees
    slices_drct   = np.roll(np.arange(10, 361, 10, dtype=np.float32), 1)
    ## slices_drct   = [360, 10.0, 20.0.......340, 350]
    n_slices_drct = slices_drct.shape[0]
    
    # speed 'slices'
    slices_sped   = [0.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 14.0, 16.0, 
                        18.0, 20.0, 22.0, 24.0, 26.0, 28.0, 30.0]
    n_slices_sped = len(slices_sped)-1

    
    # placeholder for binned wind
    binned_wind = np.zeros((n_slices_drct, n_slices_sped), 
                           dtype = np.float32)
    
    # 'trap' data points inside the bins. 
    for i in range(n_slices_drct):
        for j in range(n_slices_sped):     
            
            # because we already have drct in the multiples of 10
            foo = wind_resource[(wind_resource[:,0] == slices_drct[i])] 

            foo = foo[(foo[:,1] >= slices_sped[j]) 
                          & (foo[:,1] <  slices_sped[j+1])]
            
            binned_wind[i,j] = foo.shape[0] 
    
    wind_inst_freq   = binned_wind/np.sum(binned_wind)
    
    return(wind_inst_freq)

import random as rd
def optimize_pt(pos, i, pc, wind):
  max_aep = Aepcalc(pos,pc,wind)
  pt = pos[i]
  ptc = pos[i]
  
  gp_rem(pt)
  c = 0

  while True:
    c = c+1
    x = rd.randint(ptc[0]-100, ptc[0]+100)
    y = rd.randint(ptc[1]-100, ptc[1]+100)
    if x > 3949: x = x-3949 + 50
    elif x < 51: x = x - 51 + 3950
    elif y > 3949: y = y-3949 + 50
    elif y < 51: y = y - 51 + 3950
  
    if gp[(x-50)*3900+y-50] == 0:  
      pos[i] = np.array([x, y])           
      if Aepcalc(pos,pc,wind) > = max_aep:
        pt = np.array([x,y])
        break
    if c == 100:
      break
  gp_add(pt)
  pos[i] = pt
  print(pt)
  return



def optimize_field(pos,pc,wind):
  turb_diam = 100

  if checkConstraints(pos, turb_diam) == 0:
    print("constraint not valid")
    return()
  t = Aepcalc(pos, pc, wind)
  while t < 551:

    for i in range(len(pos)):
      print (i)
      optimize_pt(pos, i, pc, wind)
      t = Aepcalc(pos, pc, wind)
      print(t)

"""**MAIN**"""

gp_gen(pos)

gp_backup = gp

pos = getTurbLoc('Turbine1.csv')
pc = loadPowerCurve('power_curve.csv')
wind = binWindResourceData('wind_data_2007.csv')
print(Aepcalc(pos, pc, wind))
gp = gp_backup

optimize_field(pos, pc, wind)